# 🚀 Raspberry Pi Remote Device Control System

이 프로젝트는 **클라이언트-서버 구조**를 기반으로 라즈베리 파이에 연결된 다양한 하드웨어 장치(LED, FND, 부저, 조도 센서)를 원격으로 제어하고 모니터링하는 시스템입니다.

## 📖 프로젝트 소개
본 시스템은 C언어로 작성되었으며, 서버는 라즈베리 파이에서 동작하며 실시간 하드웨어 제어를 담당하고, 클라이언트는 네트워크를 통해 서버에 명령을 내리거나 센서 상태를 수신합니다. 특히 하드웨어 제어 로직을 **동적 공유 라이브러리(.so)**로 구현하여 모듈화와 확장성을 높였습니다.

## 📂 프로젝트 구조 및 파일 설명

| 경로 | 파일명 | 설명 |
|:---|:---|:---|
| `server/` | `server.c` | 백그라운드(Daemon)에서 동작하며 `.so` 라이브러리를 동적으로 로드하고 클라이언트 명령을 처리하는 메인 서버 |
| `client/` | `client.c` | TCP 소켓을 통해 서버에 제어 패킷을 전송하고 센서 상태를 모니터링하는 클라이언트 |
| `libs/` | `led.c`, `buzzer.c`, `fnd.c`, `sensor.c` | 하드웨어 제어 로직이 담긴 독립된 동적 공유 라이브러리 소스 |
| `include/` | `device_interface.h` | 공통 인터페이스, 장치 ID, 패킷 구조체 및 핀 번호 정의 헤더 |
| `/` | `Makefile` | 서버, 클라이언트 및 모든 `.so` 라이브러리 빌드를 자동화하는 스크립트 |

## 🛠 주요 기능 및 특징
1. **멀티스레딩(Multithreading)**: 
   - 조도 센서 값을 실시간 모니터링하여 자동 LED 제어.
   - 7세그먼트(FND) 숫자를 활용한 카운트다운 기능.
   - 부저를 이용한 멜로디 연주 및 중단 처리.
2. **동적 라이브러리 로딩**: `dlfcn.h`를 사용해 실행 중에 하드웨어 라이브러리를 동적으로 로드.
3. **TCP/IP 통신**: 고정된 포트(8080)와 패킷 구조체를 정의하여 안정적인 원격 제어 구현.
4. **상태 동기화**: `pthread_mutex`를 사용하여 여러 스레드가 동시에 하드웨어를 제어할 때 발생하는 신호 간섭 방지.

## 🔌 하드웨어 구성 (WiringPi 핀 맵)



[Image of Raspberry Pi GPIO pinout]


| 장치 | 기능 | 핀 번호 (wPi) | 상세 설명 |
|:---|:---|:---:|:---|
| **LED** | 상태 표시 | 26(R), 27(Y), 28(G) | softPWM을 이용한 3단계 밝기 조절 |
| **Buzzer** | 알람/멜로디 | 23 | softTone을 활용한 비행기 멜로디 연주 |
| **Sensor** | 조도 감지 | 24 | 밝기에 따른 LED 자동 점등 모드 지원 |
| **FND** | 숫자 표시 | 3(A), 0(B), 1(C), 2(D) | BCD 디코더(74LS47 등) 연동 제어 |



## ⚙️ 시작하기 (Quick Start)

### 1. 빌드 (Build)
라즈베리 파이 환경에서 `Makefile`이 있는 루트 디렉토리에서 다음 명령을 실행합니다.
```bash
make
```
### 2. 서버실행
# 기본 실행
```bash
sudo ./bin/server
# (선택) 디버깅 시 server.c에서 make_daemon() 호출을 주석 처리하면 로그 확인이 가능합니다.
```
### 3. 클라이언
```bash
./bin/client <서버_IP_주소>
```

## 🎮 사용자 메뉴 및 기능 상세 설명

클라이언트 실행 후 나타나는 각 메뉴의 상세 동작과 기술적 로직은 다음과 같습니다.

### 1. 자동 모드 복귀 (Automatic Mode)
- **동작 방식**: 조도 센서(`DEV_SENSOR`)의 실시간 상태에 따라 시스템이 하드웨어를 자동으로 제어합니다.
- **상세 로직**:
  - **어두워짐 (센서 값 1)**: 빨간색 LED(`RED_LED`)가 최대 밝기(Step 3)로 점등됩니다.
  - **밝아짐 (센서 값 0)**: 모든 LED가 즉시 소등됩니다.
- **특징**: 수동 모드에서 장치를 조작했더라도 이 메뉴를 선택하면 `sensor_auto_mode` 플래그가 활성화되어 다시 센서 기반 자동 제어 상태로 돌아갑니다.

### 2. 수동 LED 제어 (Manual LED Control)
- **색상 선택**: 빨강(1), 노랑(2), 초록(3) 중 제어할 LED를 선택합니다.
- **밝기 제어**: `softPWM` 기술을 적용하여 0(꺼짐)부터 3(최대 밝기)까지 총 4단계 제어를 지원합니다.
- **전환**: 이 명령이 수행되는 즉시 시스템은 수동 모드로 전환되어 센서의 영향을 받지 않습니다.

### 3. 사용자 카운트다운 (FND Countdown)
- **입력 범위**: 0 ~ 9 사이의 정수를 입력받습니다.
- **출력 방식**: BCD 디코더를 통해 연결된 FND(7-Segment)에 현재 숫자를 표시합니다.
- **동작**: 1초 간격으로 숫자가 감소하며, **0에 도달하는 순간** 부저(`BUZZER`)를 통해 짧은 경보음이 울려 사용자에게 알립니다.

### 4. 부저 노래 시작 (Play Melody)
- **곡명**: '비행기' 멜로디
- **스레드 처리**: 서버 측에서 독립적인 부저 스레드(`buzzer_tid`)를 생성하여 연주를 수행합니다.
- **비동기 동작**: 멜로디가 연주되는 중에도 클라이언트는 다른 메뉴를 조작하거나 센서 알림을 받는 등 중단 없는 조작이 가능합니다.

### 5. 부저 노래 중단 (Stop Melody)
- **동작**: 현재 연주 중인 멜로디를 즉시 멈추고 부저 장치를 끕니다.
- **안전 종료**: `stop_flag`를 사용하여 실행 중인 부저 스레드를 안전하게 중단시키고 리소스를 반환(`pthread_join`)합니다.

### 0. 프로그램 종료 (Exit)
- **장치 정리**: `all_devices_off()` 함수를 호출하여 모든 LED, FND, 부저를 소등 및 초기화 상태로 만듭니다.
- **통신 종료**: 소켓 연결을 끊고 클라이언트 프로그램을 안전하게 종료합니다.
